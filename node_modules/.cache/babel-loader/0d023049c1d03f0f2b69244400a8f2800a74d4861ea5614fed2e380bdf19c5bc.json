{"ast":null,"code":"// Photo storage utility for inspection photos\nimport { v4 as uuidv4 } from 'uuid';\n\n// Create inspectPhotos directory path\nconst INSPECT_PHOTOS_DIR = './inspectPhotos';\n\n// Utility to generate unique filename\nexport const generatePhotoFilename = originalName => {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const uuid = uuidv4().substring(0, 8);\n  const extension = originalName.split('.').pop();\n  return `${timestamp}_${uuid}.${extension}`;\n};\n\n// Save photo to local inspectPhotos directory\nexport const savePhotoToLocal = async (file, schoolId, inspectionId) => {\n  try {\n    // Generate unique filename\n    const filename = generatePhotoFilename(file.name);\n\n    // Create directory structure: inspectPhotos/schoolId/inspectionId/\n    const relativePath = `inspectPhotos/school_${schoolId}/inspection_${inspectionId}/${filename}`;\n\n    // In a real application, you would use Node.js fs module or a file upload service\n    // For now, we'll simulate the file save and return the path\n\n    // Convert file to base64 for storage simulation\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n      reader.onload = () => {\n        // Simulate saving to local storage\n        const photoData = {\n          id: uuidv4(),\n          filename: filename,\n          originalName: file.name,\n          path: relativePath,\n          size: file.size,\n          type: file.type,\n          data: reader.result,\n          // base64 data\n          uploadDate: new Date().toISOString(),\n          schoolId: schoolId,\n          inspectionId: inspectionId\n        };\n\n        // Store in localStorage for demo purposes\n        // In production, this would be saved to actual file system\n        const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n        existingPhotos.push(photoData);\n        localStorage.setItem('inspectionPhotos', JSON.stringify(existingPhotos));\n        resolve({\n          id: photoData.id,\n          path: relativePath,\n          filename: filename,\n          originalName: file.name,\n          size: file.size,\n          url: reader.result // For preview purposes\n        });\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(file);\n    });\n  } catch (error) {\n    console.error('Error saving photo:', error);\n    throw error;\n  }\n};\n\n// Get photo by path\nexport const getPhotoByPath = path => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    return existingPhotos.find(photo => photo.path === path);\n  } catch (error) {\n    console.error('Error retrieving photo:', error);\n    return null;\n  }\n};\n\n// Get all photos for a specific inspection\nexport const getInspectionPhotos = (schoolId, inspectionId) => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    return existingPhotos.filter(photo => photo.schoolId === schoolId && photo.inspectionId === inspectionId);\n  } catch (error) {\n    console.error('Error retrieving inspection photos:', error);\n    return [];\n  }\n};\n\n// Delete photo by ID\nexport const deletePhoto = photoId => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    const updatedPhotos = existingPhotos.filter(photo => photo.id !== photoId);\n    localStorage.setItem('inspectionPhotos', JSON.stringify(updatedPhotos));\n    return true;\n  } catch (error) {\n    console.error('Error deleting photo:', error);\n    return false;\n  }\n};\n\n// Create directory structure (simulation)\nexport const ensureDirectoryExists = (schoolId, inspectionId) => {\n  // In a real application, this would create actual directories\n  // For demo purposes, we'll just return the path structure\n  return `inspectPhotos/school_${schoolId}/inspection_${inspectionId}/`;\n};","map":{"version":3,"names":["v4","uuidv4","INSPECT_PHOTOS_DIR","generatePhotoFilename","originalName","timestamp","Date","toISOString","replace","uuid","substring","extension","split","pop","savePhotoToLocal","file","schoolId","inspectionId","filename","name","relativePath","reader","FileReader","Promise","resolve","reject","onload","photoData","id","path","size","type","data","result","uploadDate","existingPhotos","JSON","parse","localStorage","getItem","push","setItem","stringify","url","onerror","readAsDataURL","error","console","getPhotoByPath","find","photo","getInspectionPhotos","filter","deletePhoto","photoId","updatedPhotos","ensureDirectoryExists"],"sources":["/Users/prabdhar/CascadeProjects/windsurf-project/src/utils/photoStorage.js"],"sourcesContent":["// Photo storage utility for inspection photos\nimport { v4 as uuidv4 } from 'uuid';\n\n// Create inspectPhotos directory path\nconst INSPECT_PHOTOS_DIR = './inspectPhotos';\n\n// Utility to generate unique filename\nexport const generatePhotoFilename = (originalName) => {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const uuid = uuidv4().substring(0, 8);\n  const extension = originalName.split('.').pop();\n  return `${timestamp}_${uuid}.${extension}`;\n};\n\n// Save photo to local inspectPhotos directory\nexport const savePhotoToLocal = async (file, schoolId, inspectionId) => {\n  try {\n    // Generate unique filename\n    const filename = generatePhotoFilename(file.name);\n    \n    // Create directory structure: inspectPhotos/schoolId/inspectionId/\n    const relativePath = `inspectPhotos/school_${schoolId}/inspection_${inspectionId}/${filename}`;\n    \n    // In a real application, you would use Node.js fs module or a file upload service\n    // For now, we'll simulate the file save and return the path\n    \n    // Convert file to base64 for storage simulation\n    const reader = new FileReader();\n    \n    return new Promise((resolve, reject) => {\n      reader.onload = () => {\n        // Simulate saving to local storage\n        const photoData = {\n          id: uuidv4(),\n          filename: filename,\n          originalName: file.name,\n          path: relativePath,\n          size: file.size,\n          type: file.type,\n          data: reader.result, // base64 data\n          uploadDate: new Date().toISOString(),\n          schoolId: schoolId,\n          inspectionId: inspectionId\n        };\n        \n        // Store in localStorage for demo purposes\n        // In production, this would be saved to actual file system\n        const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n        existingPhotos.push(photoData);\n        localStorage.setItem('inspectionPhotos', JSON.stringify(existingPhotos));\n        \n        resolve({\n          id: photoData.id,\n          path: relativePath,\n          filename: filename,\n          originalName: file.name,\n          size: file.size,\n          url: reader.result // For preview purposes\n        });\n      };\n      \n      reader.onerror = reject;\n      reader.readAsDataURL(file);\n    });\n  } catch (error) {\n    console.error('Error saving photo:', error);\n    throw error;\n  }\n};\n\n// Get photo by path\nexport const getPhotoByPath = (path) => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    return existingPhotos.find(photo => photo.path === path);\n  } catch (error) {\n    console.error('Error retrieving photo:', error);\n    return null;\n  }\n};\n\n// Get all photos for a specific inspection\nexport const getInspectionPhotos = (schoolId, inspectionId) => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    return existingPhotos.filter(photo => \n      photo.schoolId === schoolId && photo.inspectionId === inspectionId\n    );\n  } catch (error) {\n    console.error('Error retrieving inspection photos:', error);\n    return [];\n  }\n};\n\n// Delete photo by ID\nexport const deletePhoto = (photoId) => {\n  try {\n    const existingPhotos = JSON.parse(localStorage.getItem('inspectionPhotos') || '[]');\n    const updatedPhotos = existingPhotos.filter(photo => photo.id !== photoId);\n    localStorage.setItem('inspectionPhotos', JSON.stringify(updatedPhotos));\n    return true;\n  } catch (error) {\n    console.error('Error deleting photo:', error);\n    return false;\n  }\n};\n\n// Create directory structure (simulation)\nexport const ensureDirectoryExists = (schoolId, inspectionId) => {\n  // In a real application, this would create actual directories\n  // For demo purposes, we'll just return the path structure\n  return `inspectPhotos/school_${schoolId}/inspection_${inspectionId}/`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}